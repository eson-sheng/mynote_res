<!DOCTYPE html>
<html><head><meta http-equiv='Content-Type' content='text/html; charset=utf8'><title>Professional JavaScript for Web Developers_3ed</title><script src='../res/util.js'></script><link rel='stylesheet' type='text/css' href='../res/common.css'><style>.s0{color:#0000ff;}
.s1{color:#000000;}
.s2{color:#000000;}
.s3{color:#0000ff;}
.s4{color:#000000;}
.s5{color:#0000ff;}
.s6{color:#000000;}
.s7{color:#c80000;}
.s8{color:#000000;}
.s9{color:#000000;}
.s10{color:#000000;}
.s11{color:#c80000;}
.s12{color:#c80000;}
.s13{color:#c80000;}
.s14{color:#c80000;}
.s15{color:#c80000;}
.s16{color:#000000;}
.s17{color:#000000;}
.s18{color:#c80000;}
.s19{color:#000000;}
.s20{color:#0000ff;}
.s21{color:#000000;}
.s22{color:#0000ff;}
.s23{color:#0000ff;}
.s24{color:#000000;}
</style></head><body>
<div id='outline'>
<li><a href='#ol_0' style='font-weight:bold; font-size:22px'>Professional JavaScript for Web Developers_3ed</a></li>
<li> <a href='#ol_1' >5.　引用类型　　83</a></li>
<li>  <a href='#ol_2' >5.1　Object类型　　83</a></li>
<li>  <a href='#ol_3' >5.2　Array类型　　86</a></li>
<li>   <a href='#ol_4' >5.2.1　检测数组　　88</a></li>
<li>   <a href='#ol_5' >5.2.2　转换方法　　89</a></li>
<li>   <a href='#ol_6' >5.2.3　栈方法　　90</a></li>
<li>   <a href='#ol_7' >5.2.4　队列方法　　91</a></li>
<li>   <a href='#ol_8' >5.2.5　重排序方法　　92</a></li>
<li>   <a href='#ol_9' >5.2.6　操作方法　　94</a></li>
<li>   <a href='#ol_10' >5.2.7　位置方法　　95</a></li>
<li>   <a href='#ol_11' >5.2.8　迭代方法　　96</a></li>
<li>   <a href='#ol_12' >5.2.9　缩小方法　Reduction Methods　97</a></li>
<li>  <a href='#ol_13' >5.3　Date类型　　98</a></li>
<li>  <a href='#ol_14' >5.4　RegExp类型　　103</a></li>
<li>   <a href='#ol_15' >5.4.1　RegExp实例属性　　105</a></li>
<li>   <a href='#ol_16' >5.4.2　RegExp实例方法　　106</a></li>
<li>   <a href='#ol_17' >5.4.3　RegExp构造函数属性　　107</a></li>
<li>   <a href='#ol_18' >5.4.4　模式的局限性　　109</a></li>
<li>  <a href='#ol_19' >5.5　Function类型　　110</a></li>
<li>   <a href='#ol_20' >5.5.1　没有重载（深入理解）　　111</a></li>
<li>   <a href='#ol_21' >5.5.2　函数声明与函数表达式　　111</a></li>
<li>   <a href='#ol_22' >5.5.3　作为值的函数　　112</a></li>
<li>   <a href='#ol_23' >5.5.4　函数内部属性　　113</a></li>
<li>   <a href='#ol_24' >5.5.5　函数属性和方法　　116</a></li>
<li>  <a href='#ol_25' >5.6　基本包装类型　　118</a></li>
<li>   <a href='#ol_26' >5.6.1　Boolean类型　　120</a></li>
<li>   <a href='#ol_27' >5.6.2　Number类型　　120</a></li>
<li>   <a href='#ol_28' >5.6.3　String类型　　122</a></li>
<li>  <a href='#ol_29' >5.7　单体内置对象　　130</a></li>
<li>   <a href='#ol_30' >5.7.1　Global对象　　131</a></li>
<li>   <a href='#ol_31' >5.7.2　Math对象　　134</a></li>
<li>  <a href='#ol_32' >5.8　小结　　137</a></li>
<li> <a href='#ol_33' >6.　面向对象的程序设计</a></li>
<li>  <a href='#ol_34' >6.1 理解对象</a></li>
<li>   <a href='#ol_35' >6.1.1 数据属性&amp;访问器属性</a></li>
<li>  <a href='#ol_36' >6.2 创建对象</a></li>
<li>   <a href='#ol_37' >6.2.1 工厂模式</a></li>
<li>   <a href='#ol_38' >6.2.2 ctor</a></li>
<li>   <a href='#ol_39' >6.2.3 prototype</a></li>
<li>   <a href='#ol_40' >6.2.4　组合使用构造函数模式和原型模式</a></li>
<li>   <a href='#ol_41' >6.2.5　动态原型模式</a></li>
<li>   <a href='#ol_42' >6.2.6　寄生构造函数模式</a></li>
<li>   <a href='#ol_43' >6.2.7　稳妥构造函数模式　　Durable Constructor Pattern</a></li>
<li>  <a href='#ol_44' >6.3　继承　　162</a></li>
<li>   <a href='#ol_45' >6.3.1　原型链　　162</a></li>
<li>   <a href='#ol_46' >6.3.2　借用构造函数　　167 Constructor Stealing</a></li>
<li>   <a href='#ol_47' >6.3.3　组合继承　　168 Combination Inheritance</a></li>
<li>   <a href='#ol_48' >6.3.4　原型式继承　　169 Prototypal Inheritance</a></li>
<li>   <a href='#ol_49' >6.3.5　寄生式继承　　171 Parasitic Inheritance</a></li>
<li>   <a href='#ol_50' >6.3.6　寄生组合式继承　　172 Parasitic Combination Inheritance</a></li>
<li> <a href='#ol_51' >7.　函数表达式　　175 function expressions</a></li>
<li>  <a href='#ol_52' >7.1　递归　　177</a></li>
<li>  <a href='#ol_53' >7.2　闭包　　178</a></li>
<li>   <a href='#ol_54' >7.2.1　闭包与变量　　181</a></li>
<li>   <a href='#ol_55' >7.2.2　关于this对象　　182</a></li>
<li>   <a href='#ol_56' >7.2.3　内存泄漏　　183</a></li>
<li>  <a href='#ol_57' >7.3　模仿块级作用域　　184</a></li>
<li>  <a href='#ol_58' >7.4　私有变量　　186</a></li>
<li>   <a href='#ol_59' >7.4.1　静态私有变量　　188</a></li>
<li>   <a href='#ol_60' >7.4.2　模块模式　　189</a></li>
<li>   <a href='#ol_61' >7.4.3　增强的模块模式　　191</a></li>
<li>  <a href='#ol_62' >7.5　小结　　192</a></li>
</div>

<t id='f3cda9a8-1e21-45f1-8ce4-cd7ec037925a'>
<pre><d class='s0'><br/><font size=8>Professional JavaScript for Web Developers_3ed</font>
</d><d class='s1'></d></pre>
<pre><d class='s1'>Professional JavaScript for Web Developers_3ed</d></pre>
<pre><d class='s1'></d></pre>
<pre><d class='s2'>〖X:\ebook\JavaScript\Professional JavaScript for Web Developers_3ed〗</d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s3'><h1 id='ol_1'>5.　引用类型　　83</h1>
</d><d class='s3'></d></pre>
<pre><d class='s3'><h2 id='ol_2'>5.1　Object类型　　83</h2>
</d><d class='s4'>create object: new operator & literal notation.(the Object constructor is never actually called)</d></pre>
<pre><d class='s5'></d></pre>
<pre><d class='s4'>dot notation: property name is var or contains empty</d></pre>
<pre><d class='s3'></d></pre>
<t id='f1976cec-ec13-4f25-8a3c-196d2981598b'>
<pre><d class='s0'></d><d class='s0'></d></pre>
<pre><d class='s3'><h2 id='ol_3'>5.2　Array类型　　86</h2>
</d></pre>
</t>
<pre><d class='s0'></d><d class='s4'>new 可以省略</d></pre>
<pre><d class='s4'>var colors = new Array(3); //create an array with three items</d></pre>
<pre><d class='s4'>var names = new Array(Greg); //create an array with one item, the string Greg</d></pre>
<pre><d class='s4'></d></pre>
<pre><d class='s4'>length自动更新：</d></pre>
<pre><d class='s4'>a[100] = 1;</d></pre>
<pre><d class='s4'>数字自动转为字符串property：</d></pre>
<pre><d class='s4'>a[100] = 1;</d></pre>
<pre><d class='s4'>alert(a["100"]); // 1</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s4'>可以通过设置length delete items</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s6'>To get and set array values, you use </d><d class='s7'>square brackets </d><d class='s6'>and provide the zero-based numeric index</d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s3'><h3 id='ol_4'>5.2.1　检测数组　　88</h3>
</d><d class='s4'>// iframe有问题</d></pre>
<pre><d class='s4'>if (value instanceof Array){</d></pre>
<pre><d class='s4'>// ES5</d></pre>
<pre><d class='s4'>if (Array.isArray(value)){</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s3'><h3 id='ol_5'>5.2.2　转换方法　　89</h3>
</d><d class='s4'>Array.join</d></pre>
<pre><d class='s4'>If an item in the array is null or undefined, it is represented by an empty string</d></pre>
<pre><d class='s4'>in the result of join(), toLocaleString(), toString(), and valueOf().</d><d class='s2'></d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s3'><h3 id='ol_6'>5.2.3　栈方法　　90</h3>
</d><d class='s4'>The push() method accepts any number of arguments and adds them to the end of the array,</d></pre>
<pre><d class='s4'>returning the arrays new length.</d><d class='s6'></d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s3'><h3 id='ol_7'>5.2.4　队列方法　　91</h3>
</d><d class='s4'>shift() + push()</d></pre>
<pre><d class='s4'>unshift()</d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s3'><h3 id='ol_8'>5.2.5　重排序方法　　92</h3>
</d><d class='s4'>reverse();</d></pre>
<pre><d class='s4'>sort(): 默认字符串升序</d></pre>
<pre><d class='s4'></d></pre>
<pre><d class='s4'>A much simpler version of the comparison function can be used with numeric types, and objects</d></pre>
<pre><d class='s4'>whose valueOf() method returns numeric values (such as the Date object). In either case, you can</d></pre>
<pre><d class='s4'>simply subtract the second value from the first as shown here:</d></pre>
<pre><d class='s4'>function compare(value1, value2){</d></pre>
<pre><d class='s4'>  return value2 - value1;</d></pre>
<pre><d class='s4'>}</d><d class='s2'></d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s3'><h3 id='ol_9'>5.2.6　操作方法　　94</h3>
</d><d class='s4'>colors.concat(yellow, [black, brown]);</d></pre>
<pre><d class='s4'>concat不传参等于clone</d></pre>
<pre><d class='s4'></d></pre>
<pre><d class='s4'>arr.slice() // clone</d></pre>
<pre><d class='s4'>arr.slice(begin)</d></pre>
<pre><d class='s4'>arr.slice(begin, end)</d></pre>
<pre><d class='s4'>支持negative,不支持swap</d></pre>
<pre><d class='s4'></d></pre>
<pre><d class='s4'>as delete insert replace:</d><d class='s5'></d></pre>
<pre><d class='s8'>array.splice(start)</d></pre>
<pre><d class='s8'>array.splice(start, deleteCount)</d></pre>
<pre><d class='s8'>array.splice(start, deleteCount, item1, item2, ...)</d><d class='s1'></d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s3'><h3 id='ol_10'>5.2.7　位置方法　　95</h3>
</d><d class='s4'>es5 indexOf lastIndexOf:</d></pre>
<pre><d class='s4'>as if compared using ===.</d><d class='s2'></d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s3'><h3 id='ol_11'>5.2.8　迭代方法　　96</h3>
</d><d class='s4'>ES5</d><d class='s3'></d></pre>
<pre><d class='s4'>every() filter() forEach() map() some()</d></pre>
<pre><d class='s4'>参数都是：function(item, index, array){</d><d class='s2'></d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s3'><h3 id='ol_12'>5.2.9　缩小方法　Reduction Methods　97</h3>
</d><d class='s4'>ES5</d></pre>
<pre><d class='s4'>如果只有一个元素，则返回此元素，并且不会回调。</d></pre>
<pre><d class='s4'>values.reduce(function(prev, cur, index, array){</d></pre>
<pre><d class='s4'>reduceRight()</d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s3'><h2 id='ol_13'>5.3　Date类型　　98</h2>
<a href='js.html#20a63f01-9042-4ed4-b1a3-f92f1c2acf6a'>js Date Time </a></d><d class='s1'></d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s3'><h2 id='ol_14'>5.4　RegExp类型　　103</h2>
</d><d class='s2'>The metacharacters are as follows:</d></pre>
<pre><d class='s2'>( [ { \ ^ $ | ) ] } ? * + .</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s4'>ES5 中 regular-expression literals 也需要调用ctor</d><d class='s2'></d></pre>
<pre><d class='s1'></d></pre>
<pre><d class='s3'><h3 id='ol_15'>5.4.1　RegExp实例属性　　105</h3>
</d><d class='s2'>source：两种(literal vs ctor)创建方式都一样</d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s3'><h3 id='ol_16'>5.4.2　RegExp实例方法　　106</h3>
</d><d class='s4'>exec(): 注意设置/g flag</d></pre>
<pre><d class='s4'>toLocaleString() and toString() : return literal representation</d></pre>
<pre><d class='s4'>valueOf(): return Regexp itself</d><d class='s2'></d></pre>
<pre><d class='s6'></d></pre>
<pre><d class='s3'><h3 id='ol_17'>5.4.3　RegExp构造函数属性　　107</h3>
</d><d class='s1'></d></pre>
<pre><d class='s8'>input $_</d></pre>
<pre><d class='s8'>lastMatch $&</d></pre>
<pre><d class='s8'>lastParen $+</d></pre>
<pre><d class='s8'>leftContext $`</d></pre>
<pre><d class='s8'>multiline $*</d></pre>
<pre><d class='s8'>rightContext </d><d class='s4'>$'</d></pre>
<pre><d class='s4'>RegExp.$1 ~ RegExp.$9</d><d class='s2'></d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s3'><h3 id='ol_18'>5.4.4　模式的局限性　　109</h3>
</d><d class='s2'>The \A and \Z anchors (matching the start or end of a string, respectively)</d></pre>
<pre><d class='s2'>Lookbehinds</d></pre>
<pre><d class='s2'>Union and intersection classes</d></pre>
<pre><d class='s2'>Atomic grouping</d></pre>
<pre><d class='s2'>Unicode support (except for matching a single character at a time)</d></pre>
<pre><d class='s2'>Named capturing groups</d></pre>
<pre><d class='s2'>The s (single-line) and x (free-spacing) matching modes</d></pre>
<pre><d class='s2'>Conditionals</d></pre>
<pre><d class='s2'>Regular-expression comments</d><d class='s6'></d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s3'><h2 id='ol_19'>5.5　Function类型　　110</h2>
</d><d class='s2'>var sum = new Function(num1, num2, return num1 + num2); //not recommended</d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s3'><h3 id='ol_20'>5.5.1　没有重载（深入理解）　　111</h3>
</d></pre>
<pre><d class='s3'><h3 id='ol_21'>5.5.2　函数声明与函数表达式　　111</h3>
<h3 id='ol_22'>5.5.3　作为值的函数　　112</h3>
</d><d class='s2'>function createComparisonFunction(propertyName) {</d></pre>
<pre><d class='s2'>return function(object1, object2){</d></pre>
<pre><d class='s2'>var value1 = object1[propertyName];</d></pre>
<pre><d class='s2'>var value2 = object2[propertyName];</d><d class='s9'></d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s3'><h3 id='ol_23'>5.5.4　函数内部属性　　113</h3>
</d><d class='s2'>strict mode, caller/callee error:</d></pre>
<pre><d class='s2'>These changes were made as security additions to</d></pre>
<pre><d class='s2'>the language, so third-party code could not inspect other code running in the same context.</d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s3'><h3 id='ol_24'>5.5.5　函数属性和方法　　116</h3>
</d><d class='s2'>The length property indicates</d></pre>
<pre><d class='s2'>the number of named arguments that the function expects,</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>In strict mode, the this value of a function called without a context object is</d></pre>
<pre><d class='s2'>not coerced to window. Instead, this becomes undefined unless explicitly set by</d></pre>
<pre><d class='s2'>either attaching the function to an object or using apply() or call().</d><d class='s10'></d></pre>
<pre><d class='s3'></d></pre>
<t id='4fa22678-885a-4d79-ba5c-a242afb2a6b8'>
<pre><d class='s0'></d><d class='s0'></d></pre>
<pre><d class='s3'><h2 id='ol_25'>5.6　基本包装类型　　118</h2>
</d></pre>
</t>
<pre><d class='s0'></d><d class='s2'>Every time a primitive value is read, an object of the corresponding primitive wrapper</d></pre>
<pre><d class='s2'>type is created behind the scenes, allowing access to any number of methods for manipulating the</d></pre>
<pre><d class='s2'>data.</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>就像：</d></pre>
<pre><d class='s2'>var s1 = new String(some text);</d></pre>
<pre><d class='s2'>var s2 = s1.substring(2);</d></pre>
<pre><d class='s2'>s1 = null;</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>var s1 = some text;</d></pre>
<pre><d class='s2'>s1.color = red;</d></pre>
<pre><d class='s11'>alert(s1.color); //undefined</d><d class='s2'></d></pre>
<pre><d class='s12'></d></pre>
<pre><d class='s2'>The Object constructor also acts as a factory method and is capable of returning an instance of a</d></pre>
<pre><d class='s2'>primitive wrapper based on the type of value passed into the constructor. For example:</d></pre>
<pre><d class='s2'>var obj = new Object(some text);</d></pre>
<pre><d class='s11'>alert(obj instanceof String); //true</d><d class='s9'></d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s4'>区分casting & constructor</d><d class='s3'></d></pre>
<pre><d class='s2'>var value = 25;</d></pre>
<pre><d class='s2'>var number = Number(value); //casting function</d></pre>
<pre><d class='s2'>alert(typeof number); //number</d></pre>
<pre><d class='s2'>var obj = new Number(value); //constructor</d></pre>
<pre><d class='s2'>alert(typeof obj); //object</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s3'><h3 id='ol_26'>5.6.1　Boolean类型　　120</h3>
</d><d class='s2'>var falseObject = new Boolean(false);</d></pre>
<pre><d class='s11'>var result = falseObject && true; // true</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>alert(typeof falseObject); //object</d></pre>
<pre><d class='s2'>alert(typeof falseValue); //boolean</d></pre>
<pre><d class='s2'>alert(falseObject instanceof Boolean); //true</d></pre>
<pre><d class='s2'>alert(falseValue instanceof Boolean); //false</d></pre>
<pre><d class='s2'>Its very important to understand the difference between a primitive Boolean value and a Boolean</d></pre>
<pre><d class='s2'>object - it is recommended to never use the latter.</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s3'><h3 id='ol_27'>5.6.2　Number类型　　120</h3>
<h3 id='ol_28'>5.6.3　String类型　　122</h3>
<h2 id='ol_29'>5.7　单体内置对象　　130</h2>
<h3 id='ol_30'>5.7.1　Global对象　　131</h3>
<h3 id='ol_31'>5.7.2　Math对象　　134</h3>
<h2 id='ol_32'>5.8　小结　　137</h2>
</d><d class='s1'></d></pre>
<t id='81f0f4f1-fe75-4292-af5b-f791d3f418ee'>
<pre><d class='s0'></d><d class='s0'></d></pre>
<pre><d class='s1'><h1 id='ol_33'>6.　面向对象的程序设计</h1>
</d><d class='s1'></d></pre>
<pre><d class='s1'><a href='js.html#7a8d3ea6-08fa-4ae2-bdc6-c4d244312f08'>js Object </a></d></pre>
<pre><d class='s8'>关键：new this __proto__ prototype closure</d></pre>
<pre><d class='s1'></d></pre>
<pre><d class='s3'><h2 id='ol_34'>6.1 理解对象</h2>
<h3 id='ol_35'>6.1.1 数据属性&访问器属性</h3>
</d><d class='s2'>Object.</d><d class='s13'>definePro</d><d class='s14'>p</d><d class='s13'>erty</d><d class='s2'>(obj, "key", {writable: false, ...}) 三个默认false. configurable一旦false,就不能再调用define了,可用于任何对象,include DOM,BOM</d></pre>
<pre><d class='s2'>check in console:</d></pre>
<pre><d class='s2'>Object.</d><d class='s13'>getOwnPropertyDescriptor</d><d class='s2'>(person, "name")</d></pre>
<pre><d class='s4'>Object {value: "...", </d><d class='s13'>writable</d><d class='s4'>: true, </d><d class='s13'>enumerable</d><d class='s4'>: false, </d><d class='s13'>configurable</d><d class='s4'>: true}</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>accessor:</d></pre>
<pre><d class='s2'>function g2() {</d><d class='s1'></d></pre>
<pre><d class='s1'>	var person = {</d></pre>
<pre><d class='s1'>		</d><d class='s15'>_name</d><d class='s1'>: "cyb"</d></pre>
<pre><d class='s1'>	};</d></pre>
<pre><d class='s1'>	Object.</d><d class='s15'>defineProperty</d><d class='s1'>(person, "name", {</d></pre>
<pre><d class='s1'>		get: function () {</d></pre>
<pre><d class='s1'>			return "prefix_" + _name;</d></pre>
<pre><d class='s1'>		},</d></pre>
<pre><d class='s1'>		set: function (v) {</d></pre>
<pre><d class='s1'>			_name = v;</d></pre>
<pre><d class='s1'>		}</d></pre>
<pre><d class='s1'>	});</d></pre>
<pre><d class='s1'></d></pre>
<pre><d class='s1'>	person.name = "123";</d></pre>
<pre><d class='s1'>	console.log(person.name); // </d><d class='s15'>prefix_123</d><d class='s1'></d></pre>
<pre><d class='s1'>};</d></pre>
<pre><d class='s1'>g2();</d></pre>
<pre><d class='s1'></d></pre>
<pre><d class='s1'>Object.getOwnPropertyDescriptor(person, "name")</d></pre>
<pre><d class='s1'>Object {get: function, set: function, enumerable: false, configurable: false}</d></pre>
<pre><d class='s16'></d></pre>
<pre><d class='s1'>Object.getOwnPropertyDescriptor(person, "</d><d class='s15'>__proto__</d><d class='s1'>")</d></pre>
<pre><d class='s1'>Object {value: Object, writable: true, enumerable: false, configurable: false}</d></pre>
<pre><d class='s1'></d></pre>
<pre><d class='s3'><h2 id='ol_36'>6.2 创建对象</h2>
<h3 id='ol_37'>6.2.1 工厂模式</h3>
</d><d class='s2'>: createPerson(...)</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s3'><h3 id='ol_38'>6.2.2 ctor</h3>
</d><d class='s2'>Person(){}, p = new Person(), p instanceof Person == true</d></pre>
<pre><d class='s2'>equal to:</d></pre>
<pre><d class='s11'>p = {}; Person.call(p, ...)</d><d class='s2'></d></pre>
<pre><d class='s2'>prbl: can't share function. not good idea to using global function</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s3'><h3 id='ol_39'>6.2.3 prototype</h3>
</d><d class='s2'>Person.prototype.name = "..";</d></pre>
<pre><d class='s2'>Person.prototype.sayName = function(){}..</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>1. how prototypes work</d></pre>
<pre><d class='s2'>ECMA-262 5ed, [[Prototype]], chrome等实现为__proto__,</d></pre>
<pre><d class='s2'>Person.prototype.constructor === Person</d></pre>
<pre><d class='s2'>Person.prototype.isPrototypeof(p) //true</d></pre>
<pre><d class='s2'>Object.getPrototypeof(p) == Person.prototype // ecma 5</d></pre>
<pre><d class='s11'>write to own property</d><d class='s2'>, this will hidden the prototype's, can be undone by delete.</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>2. prototype and in operator</d></pre>
<pre><d class='s2'>alert("name" in person) // both true for own or prototype</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>function hasPrototypePt(obj, name){</d></pre>
<pre><d class='s2'>	return !obj.hasOwnProerty(name) && (name in obj);</d></pre>
<pre><d class='s2'>}</d></pre>
<pre><d class='s2'>a = {"p1": 1}</d></pre>
<pre><d class='s2'>console.log(a.hasOwnProperty("p1")) // true</d></pre>
<pre><d class='s2'>console.log(hasPrototypePt(a, "p1")) // false</d></pre>
<pre><d class='s2'>console.log(hasPrototypePt(a, "__defineGetter__")) // true, 在原型链上</d></pre>
<pre><d class='s2'>console.log(hasPrototypePt(a, "freeze")) // false， 在Object function上</d></pre>
<pre><d class='s4'></d></pre>
<pre><d class='s13'>Object.prototype writable</d></pre>
<pre><d class='s4'></d></pre>
<pre><d class='s1'><a href='js.html#0af565e6-47b7-444d-a3b2-b73a11f0314b'>for in; keys; getOwnPropertyNames </a></d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>3. </d><d class='s17'>Alternate Prototype syntax</d></pre>
<pre><d class='s17'>simplify</d><d class='s2'> </d><d class='s17'>by setting prototype:</d></pre>
<pre><d class='s17'>Person.prototype = {</d></pre>
<pre><d class='s17'>  name: ..</d></pre>
<pre><d class='s18'>  prototype: Person // explicitly set back to Person. but</d><d class='s11'> </d><d class='s18'>this is enumerable.</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>4.</d><d class='s17'>Dynamic nature of prototypes</d></pre>
<pre><d class='s6'>Overwriting the prototype on the constructor means that new instances will reference the new</d></pre>
<pre><d class='s6'>prototype while any previously existing object instances still reference the old prototype.</d><d class='s2'></d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s19'>5. Native Object Prototypes</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s19'>6. Problems with Prototypes</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s20'><h3 id='ol_40'>6.2.4　组合使用构造函数模式和原型模式</h3>
</d><d class='s11'>最常用：private in instance, shared in prototype.</d></pre>
<pre><d class='s21'>function Person(name, age, job){</d></pre>
<pre><d class='s21'>this.name = name;</d></pre>
<pre><d class='s21'>this.age = age;</d></pre>
<pre><d class='s21'>this.job = job;</d></pre>
<pre><d class='s21'>this.friends = [</d><d class='s21'>Shelby</d><d class='s21'>, </d><d class='s21'>Court</d><d class='s21'>];</d></pre>
<pre><d class='s21'>}</d></pre>
<pre><d class='s21'>Person.prototype = {</d></pre>
<pre><d class='s21'>constructor: Person,</d></pre>
<pre><d class='s21'>sayName : function () {</d></pre>
<pre><d class='s21'>alert(this.name);</d></pre>
<pre><d class='s21'>}</d></pre>
<pre><d class='s21'>};</d></pre>
<pre><d class='s21'>var person1 = new Person(</d><d class='s21'>Nicholas</d><d class='s21'>, 29, </d><d class='s21'>Software Engineer</d><d class='s21'>);</d></pre>
<pre><d class='s21'>var person2 = new Person(</d><d class='s21'>Greg</d><d class='s21'>, 27, </d><d class='s21'>Doctor</d><d class='s21'>);</d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s2'>The hybrid constructor/prototype pattern is the most widely used and accepted practice for defining</d></pre>
<pre><d class='s2'>custom reference types in ECMAScript. Generally speaking, this is the default pattern to use for</d></pre>
<pre><d class='s2'>defining reference types.</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s3'><h3 id='ol_41'>6.2.5　动态原型模式</h3>
</d><d class='s2'>解决code分离问题</d></pre>
<pre><d class='s2'>        function Person(name, age, job){</d></pre>
<pre><d class='s2'>        </d></pre>
<pre><d class='s2'>            //properties</d></pre>
<pre><d class='s2'>            this.name = name;</d></pre>
<pre><d class='s2'>            this.age = age;</d></pre>
<pre><d class='s2'>            this.job = job;</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>            //methods</d></pre>
<pre><d class='s2'>            if (typeof this.sayName != "function"){</d></pre>
<pre><d class='s2'>            </d></pre>
<pre><d class='s2'>                Person.prototype.sayName = function(){</d></pre>
<pre><d class='s2'>                    alert(this.name);</d></pre>
<pre><d class='s2'>                };</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s3'><h3 id='ol_42'>6.2.6　寄生构造函数模式</h3>
</d><d class='s11'>Since you dont have direct access to the Array constructor</d></pre>
<pre><d class='s11'>不用this，override return this！</d><d class='s2'></d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>        function SpecialArray(){       </d></pre>
<pre><d class='s2'> </d></pre>
<pre><d class='s2'>            //create the array</d></pre>
<pre><d class='s2'>            var values = new Array();</d></pre>
<pre><d class='s2'>            </d></pre>
<pre><d class='s2'>            //add the values</d></pre>
<pre><d class='s2'>            values.push.apply(values, arguments);</d></pre>
<pre><d class='s2'>            </d></pre>
<pre><d class='s2'>            //assign the method</d></pre>
<pre><d class='s2'>            values.toPipedString = function(){</d></pre>
<pre><d class='s2'>                return this.join("|");</d></pre>
<pre><d class='s2'>            };</d></pre>
<pre><d class='s2'>            </d></pre>
<pre><d class='s2'>            //return it</d></pre>
<pre><d class='s2'>            return values;        </d></pre>
<pre><d class='s2'>        }</d></pre>
<pre><d class='s2'>        </d></pre>
<pre><d class='s2'>        var colors = new SpecialArray("red", "blue", "green");</d></pre>
<pre><d class='s2'>        alert(colors.toPipedString()); //"red|blue|green"</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>        alert(colors instanceof SpecialArray); // false</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s3'><h3 id='ol_43'>6.2.7　稳妥构造函数模式　　Durable Constructor Pattern</h3>
</d><d class='s13'>不用this、new</d></pre>
<pre><d class='s13'>通过closure 数据隐藏</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s3'><h2 id='ol_44'>6.3　继承　　162</h2>
</d><d class='s2'></d></pre>
<pre><d class='s13'>使用组合继承(Combination inheritance) + __proto__ 的方式最简单，书中没有用这个方式，估计是__proto__非标准</d><d class='s2'></d></pre>
<pre><d class='s2'>X:\ebook\JavaScript\Professional JavaScript for Web Developers_3ed\mycode\Ch06\inheritance.htm</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>        function SuperType(name){</d></pre>
<pre><d class='s2'>            this.name = name;</d></pre>
<pre><d class='s2'>            this.colors = ["red", "blue", "green"];</d></pre>
<pre><d class='s2'>        }</d></pre>
<pre><d class='s2'>        </d></pre>
<pre><d class='s2'>        SuperType.prototype.sayName = function(){</d></pre>
<pre><d class='s2'>            alert(this.name);</d></pre>
<pre><d class='s2'>        };</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>        function SubType(name, age){  </d></pre>
<pre><d class='s2'>            SuperType.call(this, name);</d></pre>
<pre><d class='s2'>            </d></pre>
<pre><d class='s2'>            this.age = age;</d></pre>
<pre><d class='s2'>        }</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>        </d><d class='s11'>SubType.prototype.__proto__ = SuperType.prototype; // 改了这里</d></pre>
<pre><d class='s2'>        </d></pre>
<pre><d class='s2'>        SubType.prototype.sayAge = function(){</d></pre>
<pre><d class='s2'>            alert(this.age);</d></pre>
<pre><d class='s2'>        };</d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s3'><h3 id='ol_45'>6.3.1　原型链　　162</h3>
</d><d class='s2'>PrototypeChainingExample04.htm</d></pre>
<pre><d class='s2'>        function SuperType(){</d></pre>
<pre><d class='s2'>            this.colors = ["red", "blue", "green"];</d></pre>
<pre><d class='s2'>        }</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>        function SubType(){            </d></pre>
<pre><d class='s2'>        }</d></pre>
<pre><d class='s2'>        </d></pre>
<pre><d class='s2'>        //inherit from SuperType</d></pre>
<pre><d class='s2'>        </d><d class='s11'>SubType.prototype = new SuperType();</d><d class='s2'></d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>        var instance1 = new SubType();</d></pre>
<pre><d class='s2'>        instance1.colors.push("black");</d></pre>
<pre><d class='s2'>        alert(instance1.colors);    //"red,blue,green,black"</d></pre>
<pre><d class='s2'>        </d></pre>
<pre><d class='s2'>        var instance2 = new SubType();</d></pre>
<pre><d class='s2'>        alert(instance2.colors);    //"red,blue,green,black"</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s3'><h3 id='ol_46'>6.3.2　借用构造函数　　167 Constructor Stealing</h3>
</d><d class='s2'>ConstructorStealingExample02.htm 可以传参</d></pre>
<pre><d class='s2'>        function SuperType(name){</d></pre>
<pre><d class='s2'>            this.name = name;</d></pre>
<pre><d class='s2'>        }</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>        function SubType(){  </d></pre>
<pre><d class='s2'>            //inherit from SuperType passing in an argument</d></pre>
<pre><d class='s2'>            </d><d class='s11'>SuperType.call(this, "Nicholas");</d></pre>
<pre><d class='s2'>            </d></pre>
<pre><d class='s2'>            //instance property</d></pre>
<pre><d class='s2'>            this.age = 29;</d></pre>
<pre><d class='s2'>        }</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>        var instance = new SubType();</d></pre>
<pre><d class='s2'>        alert(instance.name);    //"Nicholas";</d></pre>
<pre><d class='s2'>        alert(instance.age);     //29</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>prbl:method 不能 share</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s3'><h3 id='ol_47'>6.3.3　组合继承　　168 Combination Inheritance</h3>
</d><d class='s11'>最常用</d></pre>
<pre><d class='s11'>Addressing the downsides of both prototype chaining and constructor stealing, combination</d></pre>
<pre><d class='s11'>inheritance is the most frequently used inheritance pattern in JavaScript. It also preserves the behavior</d></pre>
<pre><d class='s11'>of instanceof and isPrototypeOf() for identifying the composition of objects.</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s13'>缺点：</d></pre>
<pre><d class='s13'>SuperType会多出一次无用的调用，更严重的是，如果要delete，需要同时delete instance 和 __proto__上的</d><d class='s11'>，见X:\ebook\JavaScript\Professional JavaScript for Web Developers_3ed\mycode\Ch06\CombinationInheritanceExample01.htm</d><d class='s2'></d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>CombinationInheritanceExample01.htm</d></pre>
<pre><d class='s2'>        function SuperType(name){</d></pre>
<pre><d class='s2'>            this.name = name;</d></pre>
<pre><d class='s2'>            this.colors = ["red", "blue", "green"];</d></pre>
<pre><d class='s2'>        }</d></pre>
<pre><d class='s2'>        </d></pre>
<pre><d class='s2'>        SuperType.prototype.sayName = function(){</d></pre>
<pre><d class='s2'>            alert(this.name);</d></pre>
<pre><d class='s2'>        };</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>        function SubType(name, age){  </d></pre>
<pre><d class='s2'>            </d><d class='s11'>SuperType.call(this, name);</d></pre>
<pre><d class='s2'>            </d></pre>
<pre><d class='s2'>            this.age = age;</d></pre>
<pre><d class='s2'>        }</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s11'>        SubType.prototype = new SuperType();</d></pre>
<pre><d class='s2'>        </d></pre>
<pre><d class='s2'>        SubType.prototype.sayAge = function(){</d></pre>
<pre><d class='s2'>            alert(this.age);</d></pre>
<pre><d class='s2'>        };</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s3'><h3 id='ol_48'>6.3.4　原型式继承　　169 Prototypal Inheritance</h3>
</d><d class='s2'>Keep in mind that properties</d></pre>
<pre><d class='s2'>containing reference values will always share those values, similar to using the prototype pattern</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>PrototypalInheritanceExample01.htm</d></pre>
<pre><d class='s2'>        function object(o){</d></pre>
<pre><d class='s2'>            function F(){}</d></pre>
<pre><d class='s2'>            F.prototype = o;</d></pre>
<pre><d class='s2'>            return new F();</d></pre>
<pre><d class='s2'>        }</d></pre>
<pre><d class='s2'>相当于js5: </d><d class='s11'>Object.create</d><d class='s2'></d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>第二个参数:</d></pre>
<pre><d class='s2'>var anotherPerson = </d><d class='s11'>Object.create</d><d class='s2'>(person, {</d></pre>
<pre><d class='s2'>name: {</d></pre>
<pre><d class='s2'>value: Greg</d></pre>
<pre><d class='s2'>}</d></pre>
<pre><d class='s2'>});</d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s3'><h3 id='ol_49'>6.3.5　寄生式继承　　171 Parasitic Inheritance</h3>
</d><d class='s2'>Keep in mind that adding functions to objects using parasitic inheritance leads</d></pre>
<pre><d class='s2'>to inefficiencies related to function reuse, similar to the constructor pattern.</d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s2'>function object(o) {</d></pre>
<pre><d class='s2'>    function F() {</d></pre>
<pre><d class='s2'>    }</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>    F.prototype = o;</d></pre>
<pre><d class='s2'>    return new F();</d></pre>
<pre><d class='s2'>}</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>function createAnother(original) {</d></pre>
<pre><d class='s2'>    var clone = object(original); //create a new object by calling a function</d></pre>
<pre><d class='s2'>    clone.sayHi = function () { //augment the object in some way</d></pre>
<pre><d class='s2'>        alert(this.friends);</d></pre>
<pre><d class='s2'>    };</d></pre>
<pre><d class='s2'>    return clone; //return the object</d></pre>
<pre><d class='s2'>}</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>var person = {</d></pre>
<pre><d class='s2'>    name: "Nicholas",</d></pre>
<pre><d class='s2'>    friends: ["Shelby", "Court", "Van"]</d></pre>
<pre><d class='s2'>};</d></pre>
<pre><d class='s2'>var anotherPerson = createAnother(person);</d></pre>
<pre><d class='s2'>anotherPerson.sayHi(); //"hi"</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s3'><h3 id='ol_50'>6.3.6　寄生组合式继承　　172 Parasitic Combination Inheritance</h3>
</d><d class='s2'>太过复杂</d></pre>
<pre><d class='s2'>ParasiticCombinationInheritanceExample01.html</d><d class='s1'></d></pre>
</t>
<pre><d class='s0'></d><d class='s22'></d></pre>
<t id='84b9a063-fc8c-4af5-88fc-59530848043e'>
<pre><d class='s0'></d><d class='s0'></d></pre>
<pre><d class='s3'><h1 id='ol_51'>7.　函数表达式　　175 function expressions</h1>
</d></pre>
</t>
<pre><d class='s0'></d><d class='s1'>//works only in Firefox, Safari, Chrome, and Opera</d></pre>
<pre><d class='s1'>alert(functionName.name); //functionName</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s4'>function declaration hoisting:</d><d class='s2'></d></pre>
<pre><d class='s2'>sayHi();</d></pre>
<pre><d class='s2'>function sayHi(){</d></pre>
<pre><d class='s2'>  alert(Hi!);</d></pre>
<pre><d class='s2'>}</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s4'>function expression:</d><d class='s2'></d></pre>
<pre><d class='s2'>var functionName = function</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>The ability to create functions for assignment to variables also allows you to return functions as</d></pre>
<pre><d class='s2'>the value of other functions.</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>匿名函数定义并执行：</d></pre>
<pre><d class='s2'>// ok</d></pre>
<pre><d class='s2'>var a = function() {</d></pre>
<pre><d class='s2'>    alert("ok");</d></pre>
<pre><d class='s2'>}();</d></pre>
<pre><d class='s2'>// ok, too</d></pre>
<pre><d class='s2'>(function() {</d></pre>
<pre><d class='s2'>    alert("ok");</d></pre>
<pre><d class='s2'>})();</d></pre>
<pre><d class='s2'>// error</d></pre>
<pre><d class='s2'>function() {</d></pre>
<pre><d class='s2'>    alert("ok");</d></pre>
<pre><d class='s2'>}();</d></pre>
<pre><d class='s2'>This code causes a syntax error, because JavaScript sees the function keyword as the beginning</d></pre>
<pre><d class='s2'>of a function declaration, and function declarations cannot be followed by parentheses. Function</d></pre>
<pre><d class='s11'>expressions</d><d class='s2'>, however, can be followed by parentheses. </d><d class='s4'>To turn the function declaration into a</d></pre>
<pre><d class='s4'>function expression, you need only surround it with parentheses like this</d><d class='s2'>:</d><d class='s22'></d></pre>
<pre><d class='s1'></d></pre>
<pre><d class='s3'><h2 id='ol_52'>7.1　递归　　177</h2>
</d><d class='s2'></d></pre>
<pre><d class='s4'>arguments.callee 用于递归,但strict mode不行,可以用named function expressions代替</d><d class='s2'></d></pre>
<pre><d class='s2'><a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee'>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee</a></d></pre>
<pre><d class='s4'>var factorial = (function f(num){});</d><d class='s2'></d></pre>
<pre><d class='s1'></d></pre>
<pre><d class='s3'><h2 id='ol_53'>7.2　闭包　　178</h2>
</d><d class='s4'>scope chain = n * AO + 1 * global varibale object</d></pre>
<pre><d class='s4'>activation object</d></pre>
<pre><d class='s4'>global variable object</d></pre>
<pre><d class='s4'>execution context</d></pre>
<pre><d class='s4'>v8对闭包有优化,不使用的就回</d><d class='s8'>收?</d><d class='s1'></d></pre>
<pre><d class='s1'></d></pre>
<pre><d class='s2'>When the function is called, an execution context is created and its scope chain is built up by</d></pre>
<pre><d class='s2'>copying the objects in the functions [[Scope]] property. After that, an activation object (which</d></pre>
<pre><d class='s2'>also acts as a variable object) is created and pushed to the front of the contexts scope chain.</d><d class='s1'></d></pre>
<pre><d class='s1'><img src='..\pic\e362d7437f990cadf9ac8a9e4b1a8bca.jpg' /></d><d class='s1'></d></pre>
<pre><d class='s1'></d></pre>
<pre><d class='s23'><h3 id='ol_54'>7.2.1　闭包与变量　　181</h3>
</d><d class='s24'>X:\ebook\JavaScript\Professional JavaScript for Web Developers_3ed\Ch07\ClosureExample02.htm</d></pre>
<pre><d class='s4'>这里只能是function expression，因此不用()</d><d class='s24'></d></pre>
<pre><d class='s2'>            function createFunctions(){</d></pre>
<pre><d class='s2'>                var result = new Array();</d></pre>
<pre><d class='s2'>                </d></pre>
<pre><d class='s2'>                for (var i=0; i &lt; 10; i++){</d></pre>
<pre><d class='s2'>                    result[i] = </d><d class='s11'>function</d><d class='s2'>(num){</d></pre>
<pre><d class='s2'>                        return </d><d class='s11'>function</d><d class='s2'>(){</d></pre>
<pre><d class='s2'>                            return num;</d></pre>
<pre><d class='s2'>                        };</d></pre>
<pre><d class='s2'>                    </d><d class='s11'>}(i);</d><d class='s2'></d></pre>
<pre><d class='s2'>                }</d></pre>
<pre><d class='s2'>                </d></pre>
<pre><d class='s2'>                return result;</d></pre>
<pre><d class='s2'>            }</d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s3'><h3 id='ol_55'>7.2.2　关于this对象　　182</h3>
</d><d class='s2'></d></pre>
<pre><d class='s4'>保存this&arguments</d><d class='s2'></d></pre>
<pre><d class='s2'>Remember that each function automatically gets two special variables as soon as the function is</d></pre>
<pre><d class='s2'>called: this and arguments. An inner function can never access these variables directly from an</d></pre>
<pre><d class='s2'>outer function.</d></pre>
<pre><d class='s2'></d></pre>
<pre><d class='s2'>object.getName(); //My Object</d></pre>
<pre><d class='s2'>(object.getName)(); //My Object</d></pre>
<pre><d class='s4'>(object.getName = object.getName)(); //The Window in non-strict mode</d><d class='s2'></d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s3'><h3 id='ol_56'>7.2.3　内存泄漏　　183</h3>
</d><d class='s6'>circular reference</d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s3'><h2 id='ol_57'>7.3　模仿块级作用域　　184</h2>
</d><d class='s4'>忽略subquent declarations</d><d class='s2'></d></pre>
<pre><d class='s2'>it simply ignores</d></pre>
<pre><d class='s2'>all subsequent declarations (though it will honor initializations).</d></pre>
<pre><d class='s3'></d></pre>
<pre><d class='s3'><h2 id='ol_58'>7.4　私有变量　　186</h2>
<h3 id='ol_59'>7.4.1　静态私有变量　　188</h3>
<h3 id='ol_60'>7.4.2　模块模式　　189</h3>
<h3 id='ol_61'>7.4.3　增强的模块模式　　191</h3>
</d></pre>
<pre><d class='s3'><h2 id='ol_62'>7.5　小结　　192</h2>
</d></pre>
</t>
<pre><d class='s23'></d><d class='s1'></d></pre>
<pre><d class='s1'></d></pre>
<pre><d class='s1'></d></pre>
<pre><d class='s1'></d></pre>
<pre><d class='s1'></d></pre>
</body></html>
